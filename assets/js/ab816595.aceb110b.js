"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[866],{18388:e=>{e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Constructs a new `Bag` object","params":[],"returns":[{"desc":"","lua_type":"Bag"}],"function_type":"static","source":{"line":96,"path":"src/Bag/init.lua"}},{"name":"destroy","desc":"Deconstructs the `Bag` object","params":[],"returns":[],"function_type":"method","source":{"line":107,"path":"src/Bag/init.lua"}},{"name":"add","desc":"Adds an object to the Bag. When the Bag is disposed of or destroyed the objects dispose method will be invoked and the reference\\nto the object will be removed from the Bag. The following types are accepted (e.g. `typeof(object)`):\\n\\n| Type | Cleanup |\\n| ---- | ------- |\\n| `Instance` | `object:Destroy()` |\\n| `RBXScriptConnection` | `object:Disconnect()` |\\n| `function` | `object()` |\\n| `thread` | `task.cancel(object)` |\\n| `table` | `object:Destroy()` _or_ `object:Disconnect()` _or_ `object:destroy()` _or_ `object:disconnect()` |\\n| `table` with `disposeMethod` | `object:<disposeMethod>()` |\\n\\n:::caution\\nAn error will be thrown if a cleanup method cannot be found for the object type that was added to the Bag\\n:::\\n\\n```lua\\n-- Adding a part to the Bag and then destroying the Bag will also destroy the part\\nlocal part = Instance.new(\\"Part\\")\\nBag:add(part)\\nBag:destroy()\\n\\n-- Adding a function to the Bag and then destroying the Bag will also call the function\\nBag:add(function()\\n\\tprint(\\"Disposed!\\")\\nend)\\nBag:destroy()\\n\\n-- Adding a table to the Bag and then destroying the Bag will call the `destroy`, \'disconnect\' or their PascalCased counterpart methods on the table if they exist\\nlocal class = {}\\nfunction class:destroy()\\n\\tprint(\\"Disposed!\\")\\nend\\nBag:add(class)\\n\\n-- Custom cleanup from table:\\nlocal tbl = {}\\nfunction tbl:DoSomething()\\n\\tprint(\\"Do something on cleanup\\")\\nend\\nBag:Add(tbl, \\"DoSomething\\")\\n```","params":[{"name":"object","desc":"Object to track","lua_type":"any"},{"name":"disposeMethod","desc":"An optional cleanup method name to call on the object","lua_type":"string?"}],"returns":[{"desc":"The object that was passed in","lua_type":"object any"}],"function_type":"method","source":{"line":164,"path":"src/Bag/init.lua"}},{"name":"remove","desc":"Removes the object from the Bag and disposes of it\\n\\n```lua\\nlocal func = Bag:add(function()\\n\\tprint(\\"Disposed!\\")\\nend)\\nBag:remove(func) -- \\"Disposed!\\" will be printed\\n```","params":[{"name":"object","desc":"Object to remove from the bag","lua_type":"any"}],"returns":[{"desc":"Whether or not the object was removed","lua_type":"boolean"}],"function_type":"method","source":{"line":183,"path":"src/Bag/init.lua"}},{"name":"dispose","desc":"Disposes of all objects in the Bag. This is the same as calling `remove` on each object added to the Bag. The ordering in which\\nthe objects are disposed of isn\'t guaranteed to match the order in which they were added\\n\\n```lua\\nlocal part = Instance.new(\\"Part\\")\\nlocal connection = part.Touched:Connect(function()\\n\\tprint(\\"Touched!\\")\\nend)\\nBag:add(part)\\nBag:add(connection)\\nBag:dispose() -- \'part\' is destroyed and \'connection\' is disconnected\\n```","params":[],"returns":[],"function_type":"method","source":{"line":210,"path":"src/Bag/init.lua"}},{"name":"attach","desc":"Attaches the `Bag` object to a Roblox `Instance`. Calling this method will detach the `Bag` from any previously attached instance. When\\nthe attached instance is removed from the game (its parent or ancestor\'s parent is set to `nil`), the Bag will automatically\\ndestroy itself. It\'s important that any references to the bag are still released when it\'s no longer being used\\n\\n:::caution\\nAn error will be thrown if `instance` is not a descendant of the game\'s DataModel\\n:::","params":[{"name":"instance","desc":"","lua_type":"Instance"}],"returns":[],"function_type":"method","source":{"line":228,"path":"src/Bag/init.lua"}}],"properties":[{"name":"className","desc":"Static property that defines the class name `Bag`","lua_type":"string","tags":["Static"],"source":{"line":29,"path":"src/Bag/init.lua"}}],"types":[{"name":"Self","desc":"","lua_type":"Bag","source":{"line":20,"path":"src/Bag/init.lua"}}],"name":"Bag","desc":"A Bag is used to store and track objects that need to be disposed of at some point. When the Bag is destroyed, all\\nobjects within the Bag are also disposed of. This class is inspired by Trove, Maid and Janitor but implements a camelCased\\ninterface and has a few differences in how it handles cleanup\\n\\n```lua\\nlocal Bag = Bag.new()\\nlocal part = Instance.new(\\"Part\\")\\nBag:add(part)\\nBag:add(part.Touched:Connect(function()\\n\\tprint(\\"Touched!\\")\\nend))\\nBag:destroy() -- \'part\' is destroyed and the \'Touched\' connection is disconnected\\n```","source":{"line":77,"path":"src/Bag/init.lua"}}')}}]);